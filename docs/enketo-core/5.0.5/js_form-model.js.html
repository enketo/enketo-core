<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>js/form-model.js - Enketo Core</title>
    
    <meta name="description" content="Extensible Enketo form engine" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/enketo/enketo-core" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h2><a href="https://github.com/enketo/enketo-core/blob/master/CHANGELOG.md" target="_blank" class="menu-item" id="change-log" >Change log</a></h2><h3>Tutorials</h3><ul><li><a href="tutorial-01-getting-started.html">Getting started</a></li><li><a href="tutorial-02-global-configuration.html">Global configuration</a></li><li><a href="tutorial-03-browser-support.html">Browser support</a></li><li><a href="tutorial-04-development.html">Development</a></li><li><a href="tutorial-05-notes-js.html">JS rules</a></li><li><a href="tutorial-06-notes-css.html">CSS rules</a></li><li><a href="tutorial-07-events.html">Available events</a></li><li><a href="tutorial-08-widgets.html">Creating/extending widgets</a></li></ul><h3>Classes</h3><ul><li><a href="AnalogScaleWidget.html">AnalogScaleWidget</a><ul class='methods'><li data-type='method'><a href="AnalogScaleWidget.html#_getHtmlStr">_getHtmlStr</a></li><li data-type='method'><a href="AnalogScaleWidget.html#_renderLabels">_renderLabels</a></li><li data-type='method'><a href="AnalogScaleWidget.html#disable">disable</a></li><li data-type='method'><a href="AnalogScaleWidget.html#enable">enable</a></li><li data-type='method'><a href="AnalogScaleWidget.html#update">update</a></li></ul></li><li><a href="ArcGisGeopicker.html">ArcGisGeopicker</a><ul class='methods'><li data-type='method'><a href="ArcGisGeopicker.html#_addDomElements">_addDomElements</a></li><li data-type='method'><a href="ArcGisGeopicker.html#_addEsriLocate">_addEsriLocate</a></li><li data-type='method'><a href="ArcGisGeopicker.html#_addRegularLocate">_addRegularLocate</a></li><li data-type='method'><a href="ArcGisGeopicker.html#_isValidGeopoint">_isValidGeopoint</a></li><li data-type='method'><a href="ArcGisGeopicker.html#_isValidLatLng">_isValidLatLng</a></li><li data-type='method'><a href="ArcGisGeopicker.html#_updateInputs">_updateInputs</a></li><li data-type='method'><a href="ArcGisGeopicker.html#_updateMap">_updateMap</a></li><li data-type='method'><a href="ArcGisGeopicker.html#_updateValue">_updateValue</a></li><li data-type='method'><a href="ArcGisGeopicker.html#disable">disable</a></li><li data-type='method'><a href="ArcGisGeopicker.html#enable">enable</a></li><li data-type='method'><a href="ArcGisGeopicker.html#update">update</a></li></ul></li><li><a href="AutocompleteSelectpicker.html">AutocompleteSelectpicker</a><ul class='methods'><li data-type='method'><a href="AutocompleteSelectpicker.html#disable">disable</a></li><li data-type='method'><a href="AutocompleteSelectpicker.html#enable">enable</a></li><li data-type='method'><a href="AutocompleteSelectpicker.html#update">update</a></li></ul></li><li><a href="Comment.html">Comment</a><ul class='methods'><li data-type='method'><a href="Comment.html#disable">disable</a></li><li data-type='method'><a href="Comment.html#enable">enable</a></li><li data-type='method'><a href="Comment.html#update">update</a></li></ul></li><li><a href="CompactPicker.html">CompactPicker</a><ul class='methods'><li data-type='method'><a href="CompactPicker.html#disable">disable</a></li><li data-type='method'><a href="CompactPicker.html#enable">enable</a></li><li data-type='method'><a href="CompactPicker.html#update">update</a></li></ul></li><li><a href="DatepickerExtended.html">DatepickerExtended</a><ul class='methods'><li data-type='method'><a href="DatepickerExtended.html#_createFakeDateInput">_createFakeDateInput</a></li><li data-type='method'><a href="DatepickerExtended.html#_setChangeHandler">_setChangeHandler</a></li><li data-type='method'><a href="DatepickerExtended.html#_setFocusHandler">_setFocusHandler</a></li><li data-type='method'><a href="DatepickerExtended.html#_setResetHandler">_setResetHandler</a></li><li data-type='method'><a href="DatepickerExtended.html#disable">disable</a></li><li data-type='method'><a href="DatepickerExtended.html#enable">enable</a></li><li data-type='method'><a href="DatepickerExtended.html#update">update</a></li></ul></li><li><a href="DatepickerMobile.html">DatepickerMobile</a><ul class='methods'><li data-type='method'><a href="DatepickerMobile.html#disable">disable</a></li><li data-type='method'><a href="DatepickerMobile.html#enable">enable</a></li><li data-type='method'><a href="DatepickerMobile.html#update">update</a></li></ul></li><li><a href="DatepickerNative.html">DatepickerNative</a><ul class='methods'><li data-type='method'><a href="DatepickerNative.html#disable">disable</a></li><li data-type='method'><a href="DatepickerNative.html#enable">enable</a></li><li data-type='method'><a href="DatepickerNative.html#update">update</a></li></ul></li><li><a href="DatetimepickerExtended.html">DatetimepickerExtended</a><ul class='methods'><li data-type='method'><a href="DatetimepickerExtended.html#disable">disable</a></li><li data-type='method'><a href="DatetimepickerExtended.html#enable">enable</a></li><li data-type='method'><a href="DatetimepickerExtended.html#update">update</a></li></ul></li><li><a href="DesktopSelectpicker.html">DesktopSelectpicker</a><ul class='methods'><li data-type='method'><a href="DesktopSelectpicker.html#_createSelectedStr">_createSelectedStr</a></li><li data-type='method'><a href="DesktopSelectpicker.html#disable">disable</a></li><li data-type='method'><a href="DesktopSelectpicker.html#enable">enable</a></li><li data-type='method'><a href="DesktopSelectpicker.html#update">update</a></li></ul></li><li><a href="DrawWidget.html">DrawWidget</a><ul class='methods'><li data-type='method'><a href="DrawWidget.html#_loadFileIntoPad">_loadFileIntoPad</a></li><li data-type='method'><a href="DrawWidget.html#disable">disable</a></li><li data-type='method'><a href="DrawWidget.html#enable">enable</a></li><li data-type='method'><a href="DrawWidget.html#update">update</a></li></ul></li><li><a href="Filepicker.html">Filepicker</a><ul class='methods'><li data-type='method'><a href="Filepicker.html#disable">disable</a></li><li data-type='method'><a href="Filepicker.html#enable">enable</a></li><li data-type='method'><a href="Filepicker.html#update">update</a></li></ul></li><li><a href="Form.html">Form</a><ul class='members'><li data-type='member'><a href="Form.html#.requiredTransformerVersion">requiredTransformerVersion</a></li><li data-type='member'><a href="Form.html#validate">validate</a></li></ul><ul class='methods'><li data-type='method'><a href="Form.html#addModule">addModule</a></li><li data-type='method'><a href="Form.html#blockPageNavigation">blockPageNavigation</a></li><li data-type='method'><a href="Form.html#getDataStr">getDataStr</a></li><li data-type='method'><a href="Form.html#getDataStrWithoutIrrelevantNodes">getDataStrWithoutIrrelevantNodes</a></li><li data-type='method'><a href="Form.html#getQuerySelectorsForLogic">getQuerySelectorsForLogic</a></li><li data-type='method'><a href="Form.html#getRelatedNodes">getRelatedNodes</a></li><li data-type='method'><a href="Form.html#goToTarget">goToTarget</a></li><li data-type='method'><a href="Form.html#grosslyViolateStandardComplianceByIgnoringCertainCalcs">grosslyViolateStandardComplianceByIgnoringCertainCalcs</a></li><li data-type='method'><a href="Form.html#init">init</a></li><li data-type='method'><a href="Form.html#isValid">isValid</a></li><li data-type='method'><a href="Form.html#replaceChoiceNameFn">replaceChoiceNameFn</a></li><li data-type='method'><a href="Form.html#resetView">resetView</a></li><li data-type='method'><a href="Form.html#setAllVals">setAllVals</a></li><li data-type='method'><a href="Form.html#validateAll">validateAll</a></li><li data-type='method'><a href="Form.html#validateContent">validateContent</a></li><li data-type='method'><a href="Form.html#validateInput">validateInput</a></li><li data-type='method'><a href="Form.html#validationUpdate">validationUpdate</a></li></ul></li><li><a href="FormModel.html">FormModel</a><ul class='methods'><li data-type='method'><a href="FormModel.html#addRepeat">addRepeat</a></li><li data-type='method'><a href="FormModel.html#determineIndex">determineIndex</a></li><li data-type='method'><a href="FormModel.html#evaluate">evaluate</a></li><li data-type='method'><a href="FormModel.html#extractTemplates">extractTemplates</a></li><li data-type='method'><a href="FormModel.html#getRepeatIndex">getRepeatIndex</a></li><li data-type='method'><a href="FormModel.html#getRepeatSeries">getRepeatSeries</a></li><li data-type='method'><a href="FormModel.html#getSecondaryInstance">getSecondaryInstance</a></li><li data-type='method'><a href="FormModel.html#getStr">getStr</a></li><li data-type='method'><a href="FormModel.html#getXPath">getXPath</a></li><li data-type='method'><a href="FormModel.html#importNode">importNode</a></li><li data-type='method'><a href="FormModel.html#init">init</a></li><li data-type='method'><a href="FormModel.html#makeBugCompliant">makeBugCompliant</a></li><li data-type='method'><a href="FormModel.html#mergeXml">mergeXml</a></li><li data-type='method'><a href="FormModel.html#node">node</a></li><li data-type='method'><a href="FormModel.html#replaceCurrentFn">replaceCurrentFn</a></li><li data-type='method'><a href="FormModel.html#replaceIndexedRepeatFn">replaceIndexedRepeatFn</a></li><li data-type='method'><a href="FormModel.html#replaceInstanceFn">replaceInstanceFn</a></li><li data-type='method'><a href="FormModel.html#setInstanceIdAndDeprecatedId">setInstanceIdAndDeprecatedId</a></li><li data-type='method'><a href="FormModel.html#shiftRoot">shiftRoot</a></li><li data-type='method'><a href="FormModel.html#trimValues">trimValues</a></li></ul></li><li><a href="Geopicker.html">Geopicker</a><ul class='methods'><li data-type='method'><a href="Geopicker.html#_addDomElements">_addDomElements</a></li><li data-type='method'><a href="Geopicker.html#_addPointBtn">_addPointBtn</a></li><li data-type='method'><a href="Geopicker.html#_convertKmlCoordinatesToLeafletCoordinates">_convertKmlCoordinatesToLeafletCoordinates</a></li><li data-type='method'><a href="Geopicker.html#_dynamicMapAvailable">_dynamicMapAvailable</a></li><li data-type='method'><a href="Geopicker.html#_editPoint">_editPoint</a></li><li data-type='method'><a href="Geopicker.html#_enableDetection">_enableDetection</a></li><li data-type='method'><a href="Geopicker.html#_enableSearch">_enableSearch</a></li><li data-type='method'><a href="Geopicker.html#_getGoogleTileLayer">_getGoogleTileLayer</a></li><li data-type='method'><a href="Geopicker.html#_getLayers">_getLayers</a></li><li data-type='method'><a href="Geopicker.html#_getLeafletTileLayer">_getLeafletTileLayer</a></li><li data-type='method'><a href="Geopicker.html#_getTileOptions">_getTileOptions</a></li><li data-type='method'><a href="Geopicker.html#_isValidGeopoint">_isValidGeopoint</a></li><li data-type='method'><a href="Geopicker.html#_isValidLatLng">_isValidLatLng</a></li><li data-type='method'><a href="Geopicker.html#_isValidLatLngList">_isValidLatLngList</a></li><li data-type='method'><a href="Geopicker.html#_loadGoogleMapsScript">_loadGoogleMapsScript</a></li><li data-type='method'><a href="Geopicker.html#_markAsInvalid">_markAsInvalid</a></li><li data-type='method'><a href="Geopicker.html#_markAsValid">_markAsValid</a></li><li data-type='method'><a href="Geopicker.html#_removePoint">_removePoint</a></li><li data-type='method'><a href="Geopicker.html#_setCurrent">_setCurrent</a></li><li data-type='method'><a href="Geopicker.html#_updateArea">_updateArea</a></li><li data-type='method'><a href="Geopicker.html#_updateInputs">_updateInputs</a></li><li data-type='method'><a href="Geopicker.html#_updateMap">_updateMap</a></li><li data-type='method'><a href="Geopicker.html#_updateMarkers">_updateMarkers</a></li><li data-type='method'><a href="Geopicker.html#_updatePolygon">_updatePolygon</a></li><li data-type='method'><a href="Geopicker.html#_updatePolyline">_updatePolyline</a></li><li data-type='method'><a href="Geopicker.html#_updateValue">_updateValue</a></li><li data-type='method'><a href="Geopicker.html#containsEmptyPoints">containsEmptyPoints</a></li><li data-type='method'><a href="Geopicker.html#disable">disable</a></li><li data-type='method'><a href="Geopicker.html#enable">enable</a></li><li data-type='method'><a href="Geopicker.html#update">update</a></li><li data-type='method'><a href="Geopicker.html#updatedPolylineWouldIntersect">updatedPolylineWouldIntersect</a></li></ul></li><li><a href="HorizontalChoices.html">HorizontalChoices</a><ul class='methods'><li data-type='method'><a href="HorizontalChoices.html#disable">disable</a></li><li data-type='method'><a href="HorizontalChoices.html#enable">enable</a></li><li data-type='method'><a href="HorizontalChoices.html#update">update</a></li></ul></li><li><a href="ImageMap.html">ImageMap</a><ul class='methods'><li data-type='method'><a href="ImageMap.html#_removeUnmatchedIds">_removeUnmatchedIds</a></li><li data-type='method'><a href="ImageMap.html#_updateImage">_updateImage</a></li><li data-type='method'><a href="ImageMap.html#disable">disable</a></li><li data-type='method'><a href="ImageMap.html#enable">enable</a></li><li data-type='method'><a href="ImageMap.html#update">update</a></li></ul></li><li><a href="ImageViewer.html">ImageViewer</a><ul class='methods'><li data-type='method'><a href="ImageViewer.html#disable">disable</a></li><li data-type='method'><a href="ImageViewer.html#enable">enable</a></li><li data-type='method'><a href="ImageViewer.html#update">update</a></li></ul></li><li><a href="MobileSelectPicker.html">MobileSelectPicker</a><ul class='methods'><li data-type='method'><a href="MobileSelectPicker.html#_showSelectedValues">_showSelectedValues</a></li><li data-type='method'><a href="MobileSelectPicker.html#disable">disable</a></li><li data-type='method'><a href="MobileSelectPicker.html#enable">enable</a></li><li data-type='method'><a href="MobileSelectPicker.html#update">update</a></li></ul></li><li><a href="Nodeset.html">Nodeset</a><ul class='methods'><li data-type='method'><a href="Nodeset.html#convert">convert</a></li><li data-type='method'><a href="Nodeset.html#getVal">getVal</a></li><li data-type='method'><a href="Nodeset.html#remove">remove</a></li><li data-type='method'><a href="Nodeset.html#setIndex">setIndex</a></li><li data-type='method'><a href="Nodeset.html#setVal">setVal</a></li><li data-type='method'><a href="Nodeset.html#validateConstraintAndType">validateConstraintAndType</a></li></ul></li><li><a href="Radiopicker.html">Radiopicker</a><ul class='methods'><li data-type='method'><a href="Radiopicker.html#disable">disable</a></li><li data-type='method'><a href="Radiopicker.html#enable">enable</a></li><li data-type='method'><a href="Radiopicker.html#update">update</a></li></ul></li><li><a href="RangeWidget.html">RangeWidget</a><ul class='methods'><li data-type='method'><a href="RangeWidget.html#_getHtmlStr">_getHtmlStr</a></li><li data-type='method'><a href="RangeWidget.html#disable">disable</a></li><li data-type='method'><a href="RangeWidget.html#enable">enable</a></li><li data-type='method'><a href="RangeWidget.html#update">update</a></li></ul></li><li><a href="RankWidget.html">RankWidget</a><ul class='methods'><li data-type='method'><a href="RankWidget.html#disable">disable</a></li><li data-type='method'><a href="RankWidget.html#enable">enable</a></li><li data-type='method'><a href="RankWidget.html#update">update</a></li></ul></li><li><a href="TextareaWidget.html">TextareaWidget</a><ul class='methods'><li data-type='method'><a href="TextareaWidget.html#disable">disable</a></li><li data-type='method'><a href="TextareaWidget.html#enable">enable</a></li><li data-type='method'><a href="TextareaWidget.html#update">update</a></li></ul></li><li><a href="TimepickerExtended.html">TimepickerExtended</a><ul class='methods'><li data-type='method'><a href="TimepickerExtended.html#disable">disable</a></li><li data-type='method'><a href="TimepickerExtended.html#enable">enable</a></li><li data-type='method'><a href="TimepickerExtended.html#update">update</a></li></ul></li><li><a href="UrlWidget.html">UrlWidget</a><ul class='methods'><li data-type='method'><a href="UrlWidget.html#disable">disable</a></li><li data-type='method'><a href="UrlWidget.html#enable">enable</a></li><li data-type='method'><a href="UrlWidget.html#update">update</a></li></ul></li><li><a href="Widget.html">Widget</a><ul class='members'><li data-type='member'><a href="Widget.html#.list">list</a></li><li data-type='member'><a href="Widget.html#.name">name</a></li><li data-type='member'><a href="Widget.html#downloadButtonHtml">downloadButtonHtml</a></li><li data-type='member'><a href="Widget.html#originalInputValue">originalInputValue</a></li><li data-type='member'><a href="Widget.html#originalInputValue">originalInputValue</a></li><li data-type='member'><a href="Widget.html#props">props</a></li><li data-type='member'><a href="Widget.html#resetButtonHtml">resetButtonHtml</a></li><li data-type='member'><a href="Widget.html#value">value</a></li><li data-type='member'><a href="Widget.html#value">value</a></li></ul><ul class='methods'><li data-type='method'><a href="Widget.html#.condition">condition</a></li><li data-type='method'><a href="Widget.html#disable">disable</a></li><li data-type='method'><a href="Widget.html#enable">enable</a></li><li data-type='method'><a href="Widget.html#update">update</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-calculate.html">calculate</a><ul class='methods'><li data-type='method'><a href="module-calculate.html#.update">update</a></li></ul></li><li><a href="module-dom-utils.html">dom-utils</a><ul class='methods'><li data-type='method'><a href="module-dom-utils.html#~empty">empty</a></li><li data-type='method'><a href="module-dom-utils.html#~getSiblingElements">getSiblingElements</a></li><li data-type='method'><a href="module-dom-utils.html#~getSiblingElementsAndSelf">getSiblingElementsAndSelf</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#_getElements">_getElements</a></li><li><a href="global.html#_instantiate">_instantiate</a></li><li><a href="global.html#_setLangChangeListener">_setLangChangeListener</a></li><li><a href="global.html#_setOptionChangeListener">_setOptionChangeListener</a></li><li><a href="global.html#_setValChangeListener">_setValChangeListener</a></li><li><a href="global.html#alert">alert</a></li><li><a href="global.html#confirm">confirm</a></li><li><a href="global.html#disable">disable</a></li><li><a href="global.html#enable">enable</a></li><li><a href="global.html#getPrintStyleSheet">getPrintStyleSheet</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#parseFunctionFromExpression">parseFunctionFromExpression</a></li><li><a href="global.html#print">print</a></li><li><a href="global.html#setDpi">setDpi</a></li><li><a href="global.html#styleReset">styleReset</a></li><li><a href="global.html#styleToAll">styleToAll</a></li><li><a href="global.html#t">t</a></li><li><a href="global.html#toArray">toArray</a></li><li><a href="global.html#updateDownloadLink">updateDownloadLink</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">js/form-model.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import MergeXML from 'mergexml/mergexml';
import { readCookie, parseFunctionFromExpression, stripQuotes } from './utils';
import $ from 'jquery';
import { getSiblingElementsAndSelf } from './dom-utils';
import FormLogicError from './form-logic-error';
import config from 'enketo/config';
import types from './types';
import event from './event';
const REPEAT_COMMENT_PREFIX = 'repeat:/';
const INSTANCE = /instance\(\s*(["'])((?:(?!\1)[A-z0-9.\-_]+))\1\s*\)/g;
const OPENROSA = /(decimal-date-time\(|pow\(|indexed-repeat\(|format-date\(|coalesce\(|join\(|max\(|min\(|random\(|substr\(|int\(|uuid\(|regex\(|now\(|today\(|date\(|if\(|boolean-from-string\(|checklist\(|selected\(|selected-at\(|round\(|area\(|position\([^)])/;
const OPENROSA_XFORMS_NS = 'http://openrosa.org/xforms';
const JAVAROSA_XFORMS_NS = 'http://openrosa.org/javarosa';
const ENKETO_XFORMS_NS = 'http://enketo.org/xforms';

//require( './plugins' );
import './extend';

const parser = new DOMParser();
let FormModel;
let Nodeset;

/**
 * Class dealing with the XML Model of a form
 *
 * @constructor
 * @param {{modelStr: string, ?instanceStr: string, ?external: &lt;{id: string, xml: xmlDocument }>, ?submitted: boolean }} data:
 *                            data object containing XML model, 
 *                            (partial) XML instance to load, 
 *                            external data array
 *                            flag to indicate whether data was submitted before
 * @param {?{?full:boolean}} options Whether to initialize the full model or only the primary instance
 */
FormModel = function( data, options ) {

    if ( typeof data === 'string' ) {
        data = {
            modelStr: data
        };
    }

    data.external = data.external || [];
    data.submitted = ( typeof data.submitted !== 'undefined' ) ? data.submitted : true;
    options = options || {};
    options.full = ( typeof options.full !== 'undefined' ) ? options.full : true;

    this.events = document.createElement( 'div' );
    this.convertedExpressions = {};
    this.templates = {};
    this.loadErrors = [];

    this.data = data;
    this.options = options;
    this.namespaces = {};
};

/**
 * Getter and setter functions
 * @type {Object}
 */
FormModel.prototype = {
    get version() {
        return this.evaluate( '/node()/@version', 'string', null, null, true );
    },
    /**
     * Gets the instance ID
     *
     * @return {string} instanceID
     */
    get instanceID() {
        return this.getMetaNode( 'instanceID' ).getVal();
    },
    /**
     * Gets the deprecated ID
     *
     * @return {string} deprecatedID
     */
    get deprecatedID() {
        return this.getMetaNode( 'deprecatedID' ).getVal() || '';
    },
    /**
     * Gets the instance Name
     *
     * @return {string} instanceID
     */
    get instanceName() {
        return this.getMetaNode( 'instanceName' ).getVal();
    },
};

/**
 * Initializes FormModel
 */
FormModel.prototype.init = function() {
    let id;
    let i;
    let instanceDoc;
    let secondaryInstanceChildren;
    const that = this;

    /**
     * Default namespaces (on a primary instance, instance child, model) would create a problem using the **native** XPath evaluator.
     * It wouldn't find any regular /path/to/nodes. The solution is to ignore these by renaming these attributes to data-xmlns.
     *
     * If the regex is later deemed too aggressive, it could target the model, primary instance and primary instance child only, after creating an XML Document.
     */
    this.data.modelStr = this.data.modelStr.replace( /\s(xmlns=("|')[^\s>]+("|'))/g, ' data-$1' );

    if ( !this.options.full ) {
        // Strip all secondary instances from string before parsing
        // This regex works because the model never includes itext in Enketo
        this.data.modelStr = this.data.modelStr.replace( /^(&lt;model\s*>&lt;instance((?!&lt;instance).)+&lt;\/instance\s*>\s*)(&lt;instance.+&lt;\/instance\s*>)*/, '$1' );
    }

    // Create the model
    try {
        id = 'model';
        // the default model
        this.xml = parser.parseFromString( this.data.modelStr, 'text/xml' );
        this.throwParserErrors( this.xml, this.data.modelStr );
        // add external data to model 
        this.data.external.forEach( instance => {
            id = `instance "${instance.id}"` || 'instance unknown';
            instanceDoc = that.getSecondaryInstance( instance.id );
            // remove any existing content that is just an XLSForm hack to pass ODK Validate
            secondaryInstanceChildren = instanceDoc.children;
            for ( i = secondaryInstanceChildren.length - 1; i >= 0; i-- ) {
                instanceDoc.removeChild( secondaryInstanceChildren[ i ] );
            }
            let rootEl;
            // instanceof Document is only supported for Enketo Validate. It is not meant to be used otherwise as it could create problems.
            if ( instance.xml instanceof XMLDocument || instance.xml instanceof Document ) {
                if ( window.navigator.userAgent.indexOf( 'Trident/' ) >= 0 ) {
                    // IE does not support importNode
                    rootEl = that.importNode( instance.xml.documentElement, true );
                } else {
                    // Create a clone of the root node
                    rootEl = that.xml.importNode( instance.xml.documentElement, true );
                }
            }
            if ( rootEl ) {
                instanceDoc.appendChild( rootEl );
            }
        } );

        // TODO: in the future, we should search for jr://instance/session and 
        // populate that one. This is just moving in that direction to implement preloads.
        this.createSession( '__session', this.data.session );
    } catch ( e ) {
        console.error( 'parseXML error' );
        this.loadErrors.push( `Error trying to parse XML ${id}. ${e.message}` );
    }

    // Initialize/process the model
    if ( this.xml ) {
        try {
            this.hasInstance = !!this.xml.querySelector( 'model > instance' );
            this.rootElement = this.xml.querySelector( 'instance > *' ) || this.xml.documentElement;
            this.setNamespaces();

            // Check if instanceID is present
            if ( !this.getMetaNode( 'instanceID' ).getElement() ) {
                that.loadErrors.push( 'Invalid primary instance. Missing instanceID node.' );
            }

            // Check if all secondary instances with an external source have been populated
            Array.prototype.slice.call( this.xml.querySelectorAll( 'model > instance[src]:empty' ) ).forEach( instance => {
                that.loadErrors.push( `External instance "${instance.id}" is empty.` );
            } );

            this.trimValues();
            this.extractTemplates();
        } catch ( e ) {
            console.error( e );
            this.loadErrors.push( `${e.name}: ${e.message}` );
        }
        // Merge an existing instance into the model, AFTER templates have been removed
        try {
            id = 'record';
            if ( this.data.instanceStr ) {
                this.mergeXml( this.data.instanceStr );
            }
            // Set the two most important meta fields before any field 'dataupdate' event fires.
            this.setInstanceIdAndDeprecatedId();
        } catch ( e ) {
            console.error( e );
            this.loadErrors.push( `Error trying to parse XML ${id}. ${e.message}` );
        }
    }

    return this.loadErrors;
};

FormModel.prototype.throwParserErrors = ( xmlDoc, xmlStr ) => {
    if ( !xmlDoc || xmlDoc.querySelector( 'parsererror' ) ) {
        throw new Error( `Invalid XML: ${xmlStr}` );
    }
};

FormModel.prototype.createSession = function( id, sessObj ) {
    let instance;
    let session;
    const model = this.xml.querySelector( 'model' );
    const fixedProps = [ 'deviceid', 'username', 'email', 'phonenumber', 'simserial', 'subscriberid' ];
    if ( !model ) {
        return;
    }

    sessObj = ( typeof sessObj === 'object' ) ? sessObj : {};
    instance = model.querySelector( `instance[id="${id}"]` );

    if ( !instance ) {
        instance = parser.parseFromString( `&lt;instance id="${id}"/>`, 'text/xml' ).documentElement;
        this.xml.adoptNode( instance );
        model.appendChild( instance );
    }

    // fixed: /sesssion/context properties
    fixedProps.forEach( prop => {
        sessObj[ prop ] = sessObj[ prop ] || readCookie( `__enketo_meta_${prop}` ) || `${prop} not found`;
    } );

    session = parser.parseFromString( `&lt;session>&lt;context>${fixedProps.map( prop => `&lt;${prop}>${sessObj[ prop ]}&lt;/${prop}>` ).join( '' )}&lt;/context>&lt;/session>`, 'text/xml' ).documentElement;

    // TODO: custom properties could be added to /session/user/data or to /session/data

    this.xml.adoptNode( session );
    instance.appendChild( session );
};

/**
 * For some unknown reason we cannot use doc.getElementById(id) or doc.querySelector('#'+id)
 * in IE11. This function is a replacement for this specifically to find a secondary instance.
 * 
 * @param  {string} id [description]
 * @return {Element}    [description]
 */
FormModel.prototype.getSecondaryInstance = function( id ) {
    let instanceEl;

    [].slice.call( this.xml.querySelectorAll( 'model > instance' ) ).some( el => {
        const idAttr = el.getAttribute( 'id' );
        if ( idAttr === id ) {
            instanceEl = el;
            return true;
        } else {
            return false;
        }
    } );

    return instanceEl;
};

/**
 * Returns a new Nodeset instance
 *
 * @param {(string|null)=} selector - [type/description]
 * @param {(string|number|null)=} index    - [type/description]
 * @param {(Object|null)=} filter   - [type/description]
 * @param filter.onlyLeaf
 * @param filter.noEmpty
 * @return {Nodeset}
 */
FormModel.prototype.node = function( selector, index, filter ) {
    return new Nodeset( selector, index, filter, this );
};

/**
 * Alternative adoptNode on IE11 (http://stackoverflow.com/questions/1811116/ie-support-for-dom-importnode)
 * TODO: remove to be replaced by separate IE11-only polyfill file/service
 */
FormModel.prototype.importNode = function( node, allChildren ) {
    let i;
    let il;
    switch ( node.nodeType ) {
        case document.ELEMENT_NODE:
            {
                const newNode = document.createElementNS( node.namespaceURI, node.nodeName );
                if ( node.attributes &amp;&amp; node.attributes.length > 0 ) {
                    for ( i = 0, il = node.attributes.length; i &lt; il; i++ ) {
                        const attr = node.attributes[ i ];
                        if ( attr.namespaceURI ) {
                            newNode.setAttributeNS( attr.namespaceURI, attr.nodeName, node.getAttributeNS( attr.namespaceURI, attr.localName ) );
                        } else {
                            newNode.setAttribute( attr.nodeName, node.getAttribute( attr.nodeName ) );
                        }
                    }
                }
                if ( allChildren &amp;&amp; node.children.length ) {
                    for ( i = 0, il = node.children.length; i &lt; il; i++ ) {
                        newNode.appendChild( this.importNode( node.children[ i ], allChildren ) );
                    }
                }
                if ( !node.children.length &amp;&amp; node.textContent ) {
                    newNode.textContent = node.textContent;
                }
                return newNode;
            }
        case document.TEXT_NODE:
        case document.CDATA_SECTION_NODE:
        case document.COMMENT_NODE:
            return document.createTextNode( node.nodeValue );
    }
};
/**
 * Merges an XML instance string into the XML Model
 *
 * @param  {string} recordStr The XML record as string
 * @param  {string} modelDoc  The XML model to merge the record into
 */
FormModel.prototype.mergeXml = function( recordStr ) {
    let modelInstanceChildStr;
    let merger;
    let modelInstanceEl;
    let modelInstanceChildEl;
    let mergeResultDoc;
    const that = this;
    let templateEls;
    let record;

    if ( !recordStr ) {
        return;
    }

    modelInstanceEl = this.xml.querySelector( 'instance' );
    modelInstanceChildEl = this.xml.querySelector( 'instance > *' ); // do not use firstChild as it may find a #textNode

    if ( !modelInstanceChildEl ) {
        throw new Error( 'Model is corrupt. It does not contain a childnode of instance' );
    }

    /** 
     * A Namespace merge problem occurs when ODK decides to invent a new namespace for a submission
     * that is different from the XForm model namespace... So we just remove this nonsense.
     */
    recordStr = recordStr.replace( /\s(xmlns=("|')[^\s>]+("|'))/g, '' );
    /**
     * Comments aren't merging in document order (which would be impossible also). 
     * This may mess up repeat functionality, so until we actually need
     * comments, we simply remove them (multiline comments are probably not removed, but we don't care about them).
     */
    recordStr = recordStr.replace( /&lt;!--[^>]*-->/g, '' );
    record = parser.parseFromString( recordStr, 'text/xml' );

    /**
     * Normally records will not contain the special "jr:template" attribute. However, we should still be able to deal with
     * this if they do, including the old hacked non-namespaced "template" attribute. 
     * https://github.com/enketo/enketo-core/issues/376
     * 
     * The solution if these are found is to delete the node.
     * 
     * Since the record is not a FormModel instance we revert to a very aggressive querySelectorAll that selects all 
     * nodes with a template attribute name IN ANY NAMESPACE.
     */

    templateEls = record.querySelectorAll( '[*|template]' );

    for ( let i = 0; i &lt; templateEls.length; i++ ) {
        templateEls[ i ].remove();
    }

    /**
     * To comply with quirky behaviour of repeats in XForms, we manually create the correct number of repeat instances
     * before merging. This resolves these two issues:
     *  a) Multiple repeat instances in record are added out of order when merged into a record that contains fewer 
     *     repeat instances, see https://github.com/kobotoolbox/enketo-express/issues/223
     *  b) If a repeat node is missing from a repeat instance (e.g. the 2nd) in a record, and that repeat instance is not 
     *     in the model, that node will be missing in the result.
     */
    // TODO: ES6 for (var node of record.querySelectorAll('*')){}
    Array.prototype.slice.call( record.querySelectorAll( '*' ) )
        .forEach( node => {
            let path;
            let repeatIndex = 0;
            let positionedPath;
            let repeatParts;
            try {
                path = that.getXPath( node, 'instance', false );
                // If this is a templated repeat (check templates)
                // or a repeat without templates
                if ( typeof that.templates[ path ] !== 'undefined' || that.getRepeatIndex( node ) > 0 ) {
                    positionedPath = that.getXPath( node, 'instance', true );
                    if ( !that.evaluate( positionedPath, 'node', null, null, true ) ) {
                        repeatParts = positionedPath.match( /([^[]+)\[(\d+)\]\//g );
                        // If the positionedPath has a non-0 repeat index followed by (at least) 1 node, avoid cloning out of order.
                        if ( repeatParts &amp;&amp; repeatParts.length > 0 ) {
                            // TODO: Does this work for triple-nested repeats. I don't really care though.
                            // repeatIndex of immediate parent repeat of deepest nested repeat in positionedPath
                            repeatIndex = repeatParts[ repeatParts.length - 1 ].match( /\[(\d+)\]/ )[ 1 ] - 1;
                        }
                        that.addRepeat( path, repeatIndex, true );
                    }
                }
            } catch ( e ) {
                console.log( 'Ignored error:', e );
            }
        } );

    /** 
     * Any default values in the model, may have been emptied in the record.
     * MergeXML will keep those default values, which would be bad, so we manually clear defaults before merging.
     */
    // first find all empty leaf nodes in record
    Array.prototype.slice.call( record.querySelectorAll( '*' ) )
        .filter( recordNode => {
            const val = recordNode.textContent;
            return recordNode.children.length === 0 &amp;&amp; val.trim().length === 0;
        } )
        .forEach( leafNode => {
            const path = that.getXPath( leafNode, 'instance', true );
            const instanceNode = that.node( path, 0 ).getElement();
            if ( instanceNode ) {
                // TODO: after dropping support for IE11, we can also use instanceNode.children.length
                if ( that.evaluate( './*', 'nodes', path, 0, true ).length === 0 ) {
                    // Select all text nodes (excluding repeat COMMENT nodes!)
                    that.evaluate( './text()', 'nodes', path, 0, true ).forEach( node => {
                        node.textContent = '';
                    } );
                } else {
                    // If the node in the default instance is a group (empty in record, so appears to be a leaf node
                    // but isn't), empty all true leaf node descendants.
                    that.evaluate( './/*[not(*)]', 'nodes', path, 0, true ).forEach( node => {
                        node.textContent = '';
                    } );
                }
            }
        } );

    merger = new MergeXML( {
        join: false
    } );

    modelInstanceChildStr = ( new XMLSerializer() ).serializeToString( modelInstanceChildEl );
    recordStr = ( new XMLSerializer() ).serializeToString( record );

    // first the model, to preserve DOM order of that of the default instance
    merger.AddSource( modelInstanceChildStr );
    // then merge the record into the model
    merger.AddSource( recordStr );

    if ( merger.error.code ) {
        throw new Error( merger.error.text );
    }

    /**
     * Beware: merge.Get(0) returns an ActiveXObject in IE11. We turn this 
     * into a proper XML document by parsing the XML string instead.
     */
    mergeResultDoc = parser.parseFromString( merger.Get( 1 ), 'text/xml' );

    /** 
     * To properly show 0 repeats, if the form definition contains multiple default instances
     * and the record contains none, we have to iterate trough the templates object, and
     * 1. check for each template path, whether the record contained more than 0 of these nodes
     * 2. remove all nodes on that path if the answer was no.
     *
     * Since this requires complex handcoded XForms it is unlikely to ever be needed, so I left this
     * functionality out.
     */

    // Remove the primary instance childnode from the original model
    this.xml.querySelector( 'instance' ).removeChild( modelInstanceChildEl );
    // checking if IE
    if ( window.navigator.userAgent.indexOf( 'Trident/' ) >= 0 ) {
        // IE does not support adoptNode
        modelInstanceChildEl = this.importNode( mergeResultDoc.documentElement, true );
    } else {
        // adopt the merged instance childnode
        modelInstanceChildEl = this.xml.adoptNode( mergeResultDoc.documentElement, true );
    }
    // append the adopted node to the primary instance
    modelInstanceEl.appendChild( modelInstanceChildEl );
    // reset the rootElement
    this.rootElement = modelInstanceChildEl;

};

/**
 * Creates an XPath from a node
 * @param { XMLElement} node XML node
 * @param  {string=} rootNodeName   if absent the root is #document
 * @param  {boolean=} includePosition whether or not to include the positions /path/to/repeat[2]/node
 * @return {string}                 XPath
 */
FormModel.prototype.getXPath = function( node, rootNodeName, includePosition ) {
    let index;
    const steps = [];
    let position = '';
    if ( !node || node.nodeType !== 1 ) {
        return null;
    }
    const nodeName = node.nodeName;
    let parent = node.parentElement;
    let parentName = parent ? parent.nodeName : null;

    rootNodeName = rootNodeName || '#document';
    includePosition = includePosition || false;

    if ( includePosition ) {
        index = this.getRepeatIndex( node );
        if ( index > 0 ) {
            position = `[${index + 1}]`;
        }
    }

    steps.push( nodeName + position );

    while ( parent &amp;&amp; parentName !== rootNodeName &amp;&amp; parentName !== '#document' ) {
        if ( includePosition ) {
            index = this.getRepeatIndex( parent );
            position = ( index > 0 ) ? `[${index + 1}]` : '';
        }
        steps.push( parentName + position );
        parent = parent.parentElement;
        parentName = parent ? parent.nodeName : null;
    }

    return `/${steps.reverse().join( '/' )}`;
};

/** 
 * Obtains the index of a repeat instance within its own series.
 * 
 * @param  {[type]} node [description]
 * @return {[type]}      [description]
 */
FormModel.prototype.getRepeatIndex = node => {
    let index = 0;
    const nodeName = node.nodeName;
    let prevSibling = node.previousSibling;

    while ( prevSibling ) {
        // ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
        if ( prevSibling.nodeName &amp;&amp; prevSibling.nodeName === nodeName ) {
            index++;
        }
        prevSibling = prevSibling.previousSibling;
    }

    return index;
};

/**
 * Trims values
 * 
 */
FormModel.prototype.trimValues = function() {
    this.node( null, null, {
        noEmpty: true
    } ).getElements().forEach( element => {
        element.textContent = element.textContent.trim();
    } );
};

/**
 * [deprecateId description]
 * @return {[type]} [description]
 */
FormModel.prototype.setInstanceIdAndDeprecatedId = function() {
    let instanceIdObj;
    let instanceIdEl;
    let deprecatedIdEl;
    let metaEl;
    let instanceIdExistingVal;

    instanceIdObj = this.getMetaNode( 'instanceID' );
    instanceIdEl = instanceIdObj.getElement();
    instanceIdExistingVal = instanceIdObj.getVal();

    if ( this.data.instanceStr &amp;&amp; this.data.submitted ) {
        deprecatedIdEl = this.getMetaNode( 'deprecatedID' ).getElement();

        // set the instanceID value to empty
        instanceIdEl.textContent = '';

        // add deprecatedID node if necessary
        if ( !deprecatedIdEl ) {
            deprecatedIdEl = parser.parseFromString( '&lt;deprecatedID/>', 'text/xml' ).documentElement;
            this.xml.adoptNode( deprecatedIdEl );
            metaEl = this.xml.querySelector( '* > meta' );
            metaEl.appendChild( deprecatedIdEl );
        }
    }

    if ( !instanceIdObj.getVal() ) {
        instanceIdObj.setVal( this.evaluate( 'concat("uuid:", uuid())', 'string' ) );
    }

    // after setting instanceID, give deprecatedID element the old value of the instanceId
    // ensure dataupdate event fires by using setVal
    if ( deprecatedIdEl ) {
        this.getMetaNode( 'deprecatedID' ).setVal( instanceIdExistingVal );
    }
};

/**
 * Creates a custom XPath Evaluator to be used for XPath Expresssions that contain custom
 * OpenRosa functions or for browsers that do not have a native evaluator.
 */
import bindJsEvaluator from './xpath-evaluator-binding';

FormModel.prototype.bindJsEvaluator = bindJsEvaluator;

FormModel.prototype.getMetaNode = function( localName ) {
    const orPrefix = this.getNamespacePrefix( OPENROSA_XFORMS_NS );
    let n = this.node( `/*/${orPrefix}:meta/${orPrefix}:${localName}` );

    if ( !n.getElement() ) {
        n = this.node( `/*/meta/${localName}` );
    }

    return n;
};

FormModel.prototype.getRepeatCommentText = path => {
    path = path.trim();
    return REPEAT_COMMENT_PREFIX + path;
};

FormModel.prototype.getRepeatCommentSelector = function( repeatPath ) {
    return `//comment()[self::comment()="${this.getRepeatCommentText( repeatPath )}"]`;
};

FormModel.prototype.getRepeatCommentEl = function( repeatPath, repeatSeriesIndex ) {
    return this.evaluate( this.getRepeatCommentSelector( repeatPath ), 'nodes', null, null, true )[ repeatSeriesIndex ];
};

/**
 * Adds a &lt;repeat>able instance node in a particular series of a repeat.
 *
 * @param  {string} repeatPath absolute path of a repeat 
 * @param  {number} repeatSeriesIndex    index of the repeat series that gets a new repeat (this is always 0 for non-nested repeats)
 * @param  {boolean} merge   whether this operation is part of a merge operation (won't send dataupdate event, clears all values and 
 *                           will not add ordinal attributes as these should be provided in the record)
 */
FormModel.prototype.addRepeat = function( repeatPath, repeatSeriesIndex, merge ) {
    let templateClone;
    const that = this;

    if ( !this.templates[ repeatPath ] ) {
        // This allows the model itself without requiring the controller to cal call .extractFakeTemplates()
        // to extract non-jr:templates by assuming that addRepeat would only called for a repeat.
        this.extractFakeTemplates( [ repeatPath ] );
    }

    const template = this.templates[ repeatPath ];
    const repeatSeries = this.getRepeatSeries( repeatPath, repeatSeriesIndex );
    const insertAfterNode = repeatSeries.length ? repeatSeries[ repeatSeries.length - 1 ] : this.getRepeatCommentEl( repeatPath, repeatSeriesIndex );

    // if not exists and not a merge operation
    if ( !merge ) {
        repeatSeries.forEach( el => {
            that.addOrdinalAttribute( el, repeatSeries[ 0 ] );
        } );
    }

    /**
     * If templatenodes and insertAfterNode(s) have been identified 
     */
    if ( template &amp;&amp; insertAfterNode ) {
        templateClone = template.cloneNode( true );
        insertAfterNode.after( templateClone );

        this.removeOrdinalAttributes( templateClone );
        // We should not automatically add ordinal attributes for an existing record as the ordinal values cannot be determined. 
        // They should be provided in the instanceStr (record).
        if ( !merge ) {
            this.addOrdinalAttribute( templateClone, repeatSeries[ 0 ] );
        }

        // If part of a merge operation (during form load) where the values will be populated from the record, defaults are not desired.
        if ( merge ) {
            Array.prototype.slice.call( templateClone.querySelectorAll( '*' ) )
                .filter( node => node.children.length === 0 )
                .forEach( node => { node.textContent = ''; } );
        }

        // Note: the addrepeat eventhandler in Form.js takes care of initializing branches etc, so no need to fire an event here.
    } else {
        console.error( 'Could not find template node and/or node to insert the clone after' );
    }
};

FormModel.prototype.addOrdinalAttribute = function( repeat, firstRepeatInSeries ) {
    let lastUsedOrdinal;
    let newOrdinal;
    const enkNs = this.getNamespacePrefix( ENKETO_XFORMS_NS );
    firstRepeatInSeries = firstRepeatInSeries || repeat;
    if ( config.repeatOrdinals === true &amp;&amp; !repeat.getAttributeNS( ENKETO_XFORMS_NS, 'ordinal' ) ) {
        // getAttributeNs and setAttributeNs results in duplicate namespace declarations on each repeat node in IE11 when serializing the model.
        // However, the regular getAttribute and setAttribute do not work properly in IE11.
        lastUsedOrdinal = firstRepeatInSeries.getAttributeNS( ENKETO_XFORMS_NS, 'last-used-ordinal' ) || 0;
        newOrdinal = Number( lastUsedOrdinal ) + 1;
        firstRepeatInSeries.setAttributeNS( ENKETO_XFORMS_NS, `${enkNs}:last-used-ordinal`, newOrdinal );

        repeat.setAttributeNS( ENKETO_XFORMS_NS, `${enkNs}:ordinal`, newOrdinal );
    }
};

FormModel.prototype.removeOrdinalAttributes = el => {
    if ( config.repeatOrdinals === true ) {
        // Find all nested repeats first (this is only used for repeats that have no template).
        // The querySelector is actually too unspecific as it matches all ordinal attributes in ANY namespace.
        // However the proper [enk\\:ordinal] doesn't work if setAttributeNS was used to add the attribute.
        const repeats = Array.prototype.slice.call( el.querySelectorAll( '[*|ordinal]' ) );
        repeats.push( el );
        for ( let i = 0; i &lt; repeats.length; i++ ) {
            repeats[ i ].removeAttributeNS( ENKETO_XFORMS_NS, 'last-used-ordinal' );
            repeats[ i ].removeAttributeNS( ENKETO_XFORMS_NS, 'ordinal' );
        }
    }
};

/**
 * Obtains a single series of repeat element;
 * 
 * @param  {string} repeatPath        The absolute path of the repeat.
 * @param  {number} repeatSeriesIndex The index of the series of that repeat.
 * @return {&lt;Element>}                Array of all repeat elements in a series.
 */
FormModel.prototype.getRepeatSeries = function( repeatPath, repeatSeriesIndex ) {
    let pathSegments;
    let nodeName;
    let checkEl;
    const repeatCommentEl = this.getRepeatCommentEl( repeatPath, repeatSeriesIndex );
    const result = [];

    // RepeatCommentEl is null if the requested repeatseries is a nested repeat and its ancestor repeat
    // has 0 instances.
    if ( repeatCommentEl ) {
        pathSegments = repeatCommentEl.textContent.substr( REPEAT_COMMENT_PREFIX.length ).split( '/' );
        nodeName = pathSegments[ pathSegments.length - 1 ];
        checkEl = repeatCommentEl.nextSibling;

        // then add all subsequent repeats
        while ( checkEl ) {
            // Ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
            // also deal with repeats that have non-repeat siblings in between them, event though that would be a bug.
            if ( checkEl.nodeName &amp;&amp; checkEl.nodeName === nodeName ) {
                result.push( checkEl );
            }
            checkEl = checkEl.nextSibling;
        }
    }

    return result;
};

FormModel.prototype.hasPreviousSiblingElementSameName = el => {
    let found = false;
    const nodeName = el.nodeName;
    el = el.previousSibling;

    while ( el ) {
        // Ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
        // also deal with repeats that have non-repeat siblings in between them, event though that would be a bug.
        if ( el.nodeName &amp;&amp; el.nodeName === nodeName ) {
            found = true;
            break;
        }
        el = el.previousSibling;
    }
    return found;
};

FormModel.prototype.hasPreviousCommentSiblingWithContent = ( node, content ) => {
    let found = false;
    node = node.previousSibling;

    while ( node ) {
        if ( node.nodeType === Node.COMMENT_NODE &amp;&amp; node.textContent === content ) {
            found = true;
            break;
        }
        node = node.previousSibling;
    }
    return found;
};

/**
 * Determines the index of a repeated node amongst all nodes with the same XPath selector
 *
 * @param  {Element} element element
 * @return {number}       [description]
 */
FormModel.prototype.determineIndex = function( element ) {
    const that = this;

    if ( element ) {
        const nodeName = element.nodeName;
        const path = this.getXPath( element, 'instance' );
        const family = Array.prototype.slice.call( this.xml.querySelectorAll( nodeName.replace( /\./g, '\\.' ) ) )
            .filter( node => path === that.getXPath( node, 'instance' ) );
        return family.length === 1 ? null : family.indexOf( element );
    } else {
        console.error( 'no node, or multiple nodes, provided to determineIndex function' );
        return -1;
    }
};

/**
 * Extracts all templates from the model and stores them in a Javascript object poperties as Jquery collections
 * @return {[type]} [description]
 */
FormModel.prototype.extractTemplates = function() {
    const that = this;

    // in reverse document order to properly deal with nested repeat templates
    this.getTemplateNodes().reverse().forEach( templateEl => {
        const xPath = that.getXPath( templateEl, 'instance' );
        that.addTemplate( xPath, templateEl );
        /*
         * Nested repeats that have a template attribute are correctly add to that.templates.
         * The template of the repeat ancestor of the nested repeat contains the correct comment.
         * However, since the ancestor repeat (template)
         */
        templateEl.remove();
    } );
};

FormModel.prototype.extractFakeTemplates = function( repeatPaths ) {
    const that = this;
    let repeat;

    repeatPaths.forEach( repeatPath => {
        // Filter by elements that are the first in a series. This means that multiple instances of nested repeats
        // all get a comment insertion point.
        repeat = that.evaluate( repeatPath, 'node', null, null, true );
        if ( repeat ) {
            that.addTemplate( repeatPath, repeat, true );
        }
    } );
};

FormModel.prototype.addRepeatComments = function( repeatPath ) {
    const comment = this.getRepeatCommentText( repeatPath );
    const that = this;
    // Find all repeat series.
    this.evaluate( repeatPath, 'nodes', null, null, true ).forEach( repeat => {
        if ( !that.hasPreviousSiblingElementSameName( repeat ) &amp;&amp; !that.hasPreviousCommentSiblingWithContent( repeat, comment ) ) {
            // Add a comment to the primary instance that serves as an insertion point for each repeat series,
            repeat.before( document.createComment( comment ) );
        }
    } );
};

FormModel.prototype.addTemplate = function( repeatPath, repeat, empty ) {
    this.addRepeatComments( repeatPath );

    if ( !this.templates[ repeatPath ] ) {
        const clone = repeat.cloneNode( true );
        clone.removeAttribute( 'template' );
        clone.removeAttribute( 'jr:template' );
        if ( empty ) {
            Array.prototype.slice.call( clone.querySelectorAll( '*' ) )
                .filter( node => node.children.length === 0 )
                .forEach( node => {
                    node.textContent = '';
                } );
        }
        // Add to templates object.
        this.templates[ repeatPath ] = clone;
    }
};

FormModel.prototype.getTemplateNodes = function() {
    const jrPrefix = this.getNamespacePrefix( JAVAROSA_XFORMS_NS );
    // For now we support both the official namespaced template and the hacked non-namespaced template attributes
    // Note: due to an MS Edge bug, we use the slow JS XPath evaluator here. It would be VERY GOOD for performance 
    // to switch back once the Edge bug is fixed. The bug results in not finding any templates.
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9544701/
    return this.evaluate( `/model/instance[1]/*//*[@template] | /model/instance[1]/*//*[@${jrPrefix}:template]`, 'nodes', null, null, false );
};

/**
 * Obtains a cleaned up string of the data instance
 *
 * @return {string}           XML string
 */
FormModel.prototype.getStr = function() {
    let dataStr = ( new XMLSerializer() ).serializeToString( this.xml.querySelector( 'instance > *' ) || this.xml.documentElement, 'text/xml' );
    // restore default namespaces
    dataStr = dataStr.replace( /\s(data-)(xmlns=("|')[^\s>]+("|'))/g, ' $2' );
    // remove repeat comments
    dataStr = dataStr.replace( new RegExp( `&lt;!--${REPEAT_COMMENT_PREFIX}\\/[^>]+-->`, 'g' ), '' );
    // If not IE, strip duplicate namespace declarations. IE doesn't manage to add a namespace declaration to the root element.
    if ( navigator.userAgent.indexOf( 'Trident/' ) === -1 ) {
        dataStr = this.removeDuplicateEnketoNsDeclarations( dataStr );
    }
    return dataStr;
};

FormModel.prototype.removeDuplicateEnketoNsDeclarations = function( xmlStr ) {
    let i = 0;
    const declarationExp = new RegExp( `( xmlns:${this.getNamespacePrefix( ENKETO_XFORMS_NS )}="${ENKETO_XFORMS_NS}")`, 'g' );
    return xmlStr.replace( declarationExp, match => {
        i++;
        if ( i > 1 ) {
            return '';
        } else {
            return match;
        }
    } );
};

/**
 * There is a huge historic issue (stemming from JavaRosa) that has resulted in the usage of incorrect formulae 
 * on nodes inside repeat nodes.
 * Those formulae use absolute paths when relative paths should have been used. See more here:
 * http://opendatakit.github.io/odk-xform-spec/#a-big-deviation-with-xforms
 *
 * Tools such as pyxform also build forms in this incorrect manner. See https://github.com/modilabs/pyxform/issues/91
 * It will take time to correct this so makeBugCompliant() aims to mimic the incorrect
 * behaviour by injecting the 1-based [position] of repeats into the XPath expressions. The resulting expression
 * will then be evaluated in a way users expect (as if the paths were relative) without having to mess up
 * the XPath Evaluator.
 *
 * E.g. '/data/rep_a/node_a' could become '/data/rep_a[2]/node_a' if the context is inside
 * the second rep_a repeat.
 *
 * This function should be removed when we can reasonbly expect not many 'old XForms' to be in use any more.
 * 
 * Already it should leave proper XPaths untouched.
 *
 * @param  {string} expr        the XPath expression
 * @param  {string} selector    of the (context) node on which expression is evaluated
 * @param  {number} index       of the instance node with that selector
 */
FormModel.prototype.makeBugCompliant = function( expr, selector, index ) {
    let target = this.node( selector, index ).getElement();

    // target is null for nested repeats if no repeats exist
    if ( !target ) {
        return expr;
    }

    const parents = [ target ];
    const that = this;

    while ( target &amp;&amp; target.parentElement &amp;&amp; target.nodeName.toLowerCase() !== 'instance' ) {
        target = target.parentElement;
        parents.push( target );
    }

    // traverse collection in reverse
    parents.forEach( element => {
        // escape any dots in the node name
        const nodeName = element.nodeName.replace( /\./g, '\\.' );
        const siblingsAndSelf = getSiblingElementsAndSelf( element, `${nodeName}:not([template])` );

        // if the node is a repeat node that has been cloned at least once (i.e. if it has siblings with the same nodeName)
        if ( siblingsAndSelf.length > 1 ) {
            const parentSelector = that.getXPath( element, 'instance' );
            const parentIndex = siblingsAndSelf.indexOf( element );
            // Add position to segments that do not have an XPath predicate.
            expr = expr.replace( new RegExp( `${parentSelector}/`, 'g' ), `${parentSelector}[${parentIndex + 1}]/` );
        }
    } );

    return expr;
};

FormModel.prototype.setNamespaces = function() {
    /**
     * Passing through all nodes would be very slow with an XForms model that contains lots of nodes such as large secondary instances. 
     * (The namespace XPath axis is not support in native browser XPath evaluators unfortunately).
     * 
     * For now it has therefore been restricted to only look at the top-level node in the primary instance and in the secondary instances.
     * We can always expand that later.
     */
    const start = this.hasInstance ? '/model/instance' : '';
    const nodes = this.evaluate( `${start}/*`, 'nodes', null, null, true );
    const that = this;
    let prefix;

    nodes.forEach( node => {
        if ( node.hasAttributes() ) {
            Array.from( node.attributes ).forEach( attribute => {
                if ( attribute.name.indexOf( 'xmlns:' ) === 0 ) {
                    that.namespaces[ attribute.name.substring( 6 ) ] = attribute.value;
                }
            } );
        }
        // add required namespaces to resolver and document if they are missing
        [
            [ 'orx', OPENROSA_XFORMS_NS, false ],
            [ 'jr', JAVAROSA_XFORMS_NS, false ],
            [ 'enk', ENKETO_XFORMS_NS, config.repeatOrdinals === true ]
        ].forEach( arr => {
            if ( !that.getNamespacePrefix( arr[ 1 ] ) ) {
                prefix = ( !that.namespaces[ arr[ 0 ] ] ) ? arr[ 0 ] : `__${arr[ 0 ]}`;
                // add to resolver
                that.namespaces[ prefix ] = arr[ 1 ];
                // add to document
                if ( arr[ 2 ] ) {
                    node.setAttributeNS( 'http://www.w3.org/2000/xmlns/', `xmlns:${prefix}`, arr[ 1 ] );
                }
            }
        } );
    } );

};

FormModel.prototype.getNamespacePrefix = function( namespace ) {
    const found = Object.entries( this.namespaces ).find( arr => arr[ 1 ] === namespace );
    return found ? found[ 0 ] : undefined;


};

FormModel.prototype.getNsResolver = function() {
    const namespaces = ( typeof this.namespaces === 'undefined' ) ? {} : this.namespaces;

    return {
        lookupNamespaceURI( prefix ) {
            return namespaces[ prefix ] || null;
        }
    };
};


/**
 * Shift root to first instance for all absolute paths not starting with /model
 *
 * @param  {string} expr original expression
 * @return {string}      new expression
 */
FormModel.prototype.shiftRoot = function( expr ) {
    const LITERALS = /"([^"]*)(")|'([^']*)(')/g;
    if ( this.hasInstance ) {
        // Encode all string literals in order to exclude them, without creating a monsterly regex
        expr = expr.replace( LITERALS, ( m, p1, p2, p3, p4 ) => {
            const encoded = typeof p1 !== 'undefined' ? encodeURIComponent( p1 ) : encodeURIComponent( p3 );
            const quote = p2 || p4;
            return quote + encoded + quote;
        } );
        // Insert /model/instance[1]
        expr = expr.replace( /^(\/(?!model\/)[^/][^/\s,"']*\/)/g, '/model/instance[1]$1' );
        expr = expr.replace( /([^a-zA-Z0-9.\])/*_-])(\/(?!model\/)[^/][^/\s,"']*\/)/g, '$1/model/instance[1]$2' );
        // Decode string literals
        expr = expr.replace( LITERALS, ( m, p1, p2, p3, p4 ) => {
            const decoded = typeof p1 !== 'undefined' ? decodeURIComponent( p1 ) : decodeURIComponent( p3 );
            const quote = p2 || p4;
            return quote + decoded + quote;
        } );
    }
    return expr;
};

/** 
 * Replace instance('id') with an absolute path
 * Doing this here instead of adding an instance() function to the XPath evaluator, means we can keep using
 * the much faster native evaluator in most cases!
 *
 * @param  {string} expr original expression
 * @return {string}      new expression
 */
FormModel.prototype.replaceInstanceFn = function( expr ) {
    let prefix;
    const that = this;

    // TODO: would be more consistent to use utls.parseFunctionFromExpression() and utils.stripQuotes
    return expr.replace( INSTANCE, ( match, quote, id ) => {
        prefix = `/model/instance[@id="${id}"]`;
        // check if referred instance exists in model
        if ( that.evaluate( prefix, 'nodes', null, null, true ).length ) {
            return prefix;
        } else {
            throw new FormLogicError( `instance "${id}" does not exist in model` );
        }
    } );
};

/** 
 * Replaces current() with /absolute/path/to/node to ensure the context is shifted to the primary instance
 * 
 * Doing this here instead of adding a current() function to the XPath evaluator, means we can keep using
 * the much faster native evaluator in most cases!
 *
 * Root will be shifted, and repeat positions injected, **later on**, so it's not included here.
 *
 * @param  {string} expr            original expression
 * @param  {string} contextSelector context selector 
 * @return {string}                 new expression
 */
FormModel.prototype.replaceCurrentFn = ( expr, contextSelector ) => {
    // relative paths
    if ( contextSelector ) {
        expr = expr.replace( 'current()/.', `${contextSelector}/.` );
    }
    // absolute paths
    expr = expr.replace( 'current()/', '/' );

    return expr;
};

/**
 * Replaces indexed-repeat(node, path, position, path, position, etc) substrings by converting them
 * to their native XPath equivalents using [position() = x] predicates
 *
 * @param  {string} expr the XPath expression
 * @return {string}      converted XPath expression
 */
FormModel.prototype.replaceIndexedRepeatFn = function( expr, selector, index ) {
    const that = this;
    const indexedRepeats = parseFunctionFromExpression( expr, 'indexed-repeat' );

    indexedRepeats.forEach( indexedRepeat => {
        let i, positionedPath;
        let position;
        const params = indexedRepeat[ 1 ];

        if ( params.length % 2 === 1 ) {

            positionedPath = params[ 0 ];

            for ( i = params.length - 1; i > 1; i -= 2 ) {
                // The position will become an XPath predicate. The context for an XPath predicate, is not the same
                // as the context for the complete expression, so we have to evaluate the position separately. Otherwise 
                // relative paths would break.
                position = !isNaN( params[ i ] ) ? params[ i ] : that.evaluate( params[ i ], 'number', selector, index, true );
                positionedPath = positionedPath.replace( params[ i - 1 ], `${params[ i - 1 ]}[position() = ${position}]` );
            }

            expr = expr.replace( indexedRepeat[ 0 ], positionedPath );

        } else {
            throw new FormLogicError( `indexed repeat with incorrect number of parameters found: ${indexedRepeat[ 0 ]}` );
        }
    } );

    return expr;
};

FormModel.prototype.replaceVersionFn = function( expr ) {
    const that = this;
    let version;
    const versions = parseFunctionFromExpression( expr, 'version' );

    versions.forEach( versionPart => {
        version = version || that.evaluate( '/node()/@version', 'string', null, 0, true );
        // ignore arguments
        expr = expr.replace( versionPart[ 0 ], `"${version}"` );
    } );

    return expr;
};

FormModel.prototype.replacePullDataFn = function( expr, selector, index ) {
    let pullDataResult;
    const that = this;
    const replacements = this.convertPullDataFn( expr, selector, index );

    for ( const pullData in replacements ) {
        if ( replacements.hasOwnProperty( pullData ) ) {
            // We evaluate this here, so we can use the native evaluator safely. This speeds up pulldata() by about a factor *740*!
            pullDataResult = that.evaluate( replacements[ pullData ], 'string', selector, index, true );
            expr = expr.replace( pullData, `"${pullDataResult}"` );
        }
    }
    return expr;
};

FormModel.prototype.convertPullDataFn = function( expr, selector, index ) {
    const that = this;
    const pullDatas = parseFunctionFromExpression( expr, 'pulldata' );
    const replacements = {};

    if ( !pullDatas.length ) {
        return replacements;
    }

    pullDatas.forEach( pullData => {
        let searchValue;
        let searchXPath;
        const params = pullData[ 1 ];

        if ( params.length === 4 ) {

            // strip quotes
            params[ 1 ] = stripQuotes( params[ 1 ] );
            params[ 2 ] = stripQuotes( params[ 2 ] );

            // TODO: the 2nd and 3rd parameter could probably also be expressions.

            // The 4th argument will become an XPath predicate. The context for an XPath predicate, is not the same
            // as the context for the complete expression, so we have to evaluate the position separately. Otherwise
            // relative paths would break.
            searchValue = that.evaluate( params[ 3 ], 'string', selector, index, true );
            searchValue = searchValue === '' || isNaN( searchValue ) ? `'${searchValue}'` : searchValue;
            searchXPath = `instance(${params[ 0 ]})/root/item[${params[ 2 ]} = ${searchValue}]/${params[ 1 ]}`;

            replacements[ pullData[ 0 ] ] = searchXPath;

        } else {
            throw new FormLogicError( `pulldata with incorrect number of parameters found: ${pullData[ 0 ]}` );
        }
    } );

    return replacements;
};

/**
 * Evaluates an XPath Expression using XPathJS_javarosa (not native XPath 1.0 evaluator)
 *
 * This function does not seem to work properly for nodeset resulttypes otherwise:
 * muliple nodes can be accessed by returned node.snapshotItem(i)(.textContent)
 * a single node can be accessed by returned node(.textContent)
 *
 * @param  { string }     expr        the expression to evaluate
 * @param  { string= }    resTypeStr  boolean, string, number, node, nodes (best to always supply this)
 * @param  { string= }    selector    query selector which will be use to provide the context to the evaluator
 * @param  { number= }    index       0-based index of selector in document
 * @param  { boolean= }   tryNative   whether an attempt to try the Native Evaluator is safe (ie. whether it is
 *                                    certain that there are no date comparisons)
 * @return { ?(number|string|boolean|Array&lt;element>) } the result
 */
FormModel.prototype.evaluate = function( expr, resTypeStr, selector, index, tryNative ) {
    let j, context, doc, resTypeNum, resultTypes, result, collection, response, repeats, cacheKey, original, cacheable;

    // console.debug( 'evaluating expr: ' + expr + ' with context selector: ' + selector + ', 0-based index: ' +
    //    index + ' and result type: ' + resTypeStr );
    original = expr;
    tryNative = tryNative || false;
    resTypeStr = resTypeStr || 'any';
    index = index || 0;
    doc = this.xml;
    repeats = null;

    if ( selector ) {
        collection = this.node( selector ).getElements();
        repeats = collection.length;
        context = collection[ index ];
    } else {
        // either the first data child of the first instance or the first child (for loaded instances without a model)
        context = this.rootElement;
    }

    if ( !context ) {
        console.error( 'no context element found', selector, index );
    }

    // cache key includes the number of repeated context nodes, 
    // to force a new cache item if the number of repeated changes to > 0
    // TODO: these cache keys can get quite large. Would it be beneficial to get the md5 of the key?
    cacheKey = [ expr, selector, index, repeats ].join( '|' );

    // These functions need to come before makeBugCompliant.
    // An expression transformation with indexed-repeat or pulldata cannot be cached because in 
    // "indexed-repeat(node, repeat nodeset, index)" the index parameter could be an expression.
    expr = this.replaceIndexedRepeatFn( expr, selector, index );
    expr = this.replacePullDataFn( expr, selector, index );
    cacheable = ( original === expr );

    // if no cached conversion exists
    if ( !this.convertedExpressions[ cacheKey ] ) {
        expr = expr.trim();
        expr = this.replaceInstanceFn( expr );
        expr = this.replaceVersionFn( expr );
        expr = this.replaceCurrentFn( expr, this.getXPath( context, 'instance', true ) );
        // shiftRoot should come after replaceCurrentFn
        expr = this.shiftRoot( expr );
        // path corrections for repeated nodes: http://opendatakit.github.io/odk-xform-spec/#a-big-deviation-with-xforms
        if ( repeats &amp;&amp; repeats > 1 ) {
            expr = this.makeBugCompliant( expr, selector, index );
        }
        // decode
        expr = expr.replace( /&amp;lt;/g, '&lt;' );
        expr = expr.replace( /&amp;gt;/g, '>' );
        expr = expr.replace( /&amp;quot;/g, '"' );
        if ( cacheable ) {
            this.convertedExpressions[ cacheKey ] = expr;
        }
    } else {
        expr = this.convertedExpressions[ cacheKey ];
    }

    resultTypes = {
        0: [ 'any', 'ANY_TYPE' ],
        1: [ 'number', 'NUMBER_TYPE', 'numberValue' ],
        2: [ 'string', 'STRING_TYPE', 'stringValue' ],
        3: [ 'boolean', 'BOOLEAN_TYPE', 'booleanValue' ],
        7: [ 'nodes', 'ORDERED_NODE_SNAPSHOT_TYPE' ],
        9: [ 'node', 'FIRST_ORDERED_NODE_TYPE', 'singleNodeValue' ]
    };

    // translate typeStr to number according to DOM level 3 XPath constants
    for ( resTypeNum in resultTypes ) {
        if ( resultTypes.hasOwnProperty( resTypeNum ) ) {
            resTypeNum = Number( resTypeNum );
            if ( resultTypes[ resTypeNum ][ 0 ] === resTypeStr ) {
                break;
            } else {
                resTypeNum = 0;
            }
        }
    }

    // try native to see if that works... (will not work if the expr contains custom OpenRosa functions)
    if ( tryNative &amp;&amp; typeof doc.evaluate !== 'undefined' &amp;&amp; !OPENROSA.test( expr ) ) {
        try {
            // console.log( 'trying the blazing fast native XPath Evaluator for', expr, index );
            result = doc.evaluate( expr, context, this.getNsResolver(), resTypeNum, null );
        } catch ( e ) {
            console.log( '%cWell native XPath evaluation did not work... No worries, worth a shot, the expression probably ' +
                'contained unknown OpenRosa functions or errors:', 'color:orange', expr );
        }
    }

    // if that didn't work, try the slow XPathJS evaluator 
    if ( !result ) {
        try {
            if ( typeof doc.jsEvaluate === 'undefined' ) {
                this.bindJsEvaluator();
            }
            // console.log( 'trying the slow enketo-xpathjs "openrosa" evaluator for', expr, index );
            result = doc.jsEvaluate( expr, context, this.getNsResolver(), resTypeNum, null );
        } catch ( e ) {
            throw new FormLogicError( `Could not evaluate: ${expr}, message: ${e.message}` );
        }
    }

    // get desired value from the result object
    if ( result ) {
        // for type = any, see if a valid string, number or boolean is returned
        if ( resTypeNum === 0 ) {
            for ( resTypeNum in resultTypes ) {
                if ( resultTypes.hasOwnProperty( resTypeNum ) ) {
                    resTypeNum = Number( resTypeNum );
                    if ( resTypeNum === Number( result.resultType ) &amp;&amp; resTypeNum > 0 &amp;&amp; resTypeNum &lt; 4 ) {
                        response = result[ resultTypes[ resTypeNum ][ 2 ] ];
                        break;
                    }
                }
            }
            console.error( `Expression: ${expr} did not return any boolean, string or number value as expected` );
        } else if ( resTypeNum === 7 ) {
            // response is an array of Elements
            response = [];
            for ( j = 0; j &lt; result.snapshotLength; j++ ) {
                response.push( result.snapshotItem( j ) );
            }
        } else {
            response = result[ resultTypes[ resTypeNum ][ 2 ] ];
        }
        return response;
    }
};

/**
 * Class dealing with nodes and nodesets of the XML instance
 *
 * @constructor
 * @param {string=} selector simpleXPath or jQuery selectedor
 * @param {number=} index    the index of the target node with that selector
 * @param {?{onlyLeaf: boolean, noEmpty: boolean}=} filter   filter object for the result nodeset
 * @param { FormModel } model instance of FormModel
 */
Nodeset = function( selector, index, filter, model ) {
    const defaultSelector = model.hasInstance ? '/model/instance[1]//*' : '//*';

    this.model = model;
    this.originalSelector = selector;
    this.selector = ( typeof selector === 'string' &amp;&amp; selector.length > 0 ) ? selector : defaultSelector;
    filter = ( typeof filter !== 'undefined' &amp;&amp; filter !== null ) ? filter : {};
    this.filter = filter;
    this.filter.onlyLeaf = ( typeof filter.onlyLeaf !== 'undefined' ) ? filter.onlyLeaf : false;
    this.filter.noEmpty = ( typeof filter.noEmpty !== 'undefined' ) ? filter.noEmpty : false;
    this.index = index;
};

Nodeset.prototype.getElement = function() {
    return this.getElements()[ 0 ];
};

Nodeset.prototype.getElements = function() {
    let nodes;
    let /** @type {string} */ val;

    // cache evaluation result
    if ( !this._nodes ) {
        this._nodes = this.model.evaluate( this.selector, 'nodes', null, null, true );
        // noEmpty automatically excludes non-leaf nodes
        if ( this.filter.noEmpty === true ) {
            this._nodes = this._nodes
                .filter( node => {
                    val = node.textContent;
                    return node.children.length === 0 &amp;&amp; val.trim().length > 0;
                } );
        }
        // this may still contain empty leaf nodes
        else if ( this.filter.onlyLeaf === true ) {
            this._nodes = this._nodes
                .filter( node => node.children.length === 0 );
        }
    }

    nodes = this._nodes;

    if ( typeof this.index !== 'undefined' &amp;&amp; this.index !== null ) {
        nodes = typeof nodes[ this.index ] === 'undefined' ? [] : [ nodes[ this.index ] ];
    }

    return nodes;
};

/**
 * Sets the index of the Nodeset instance
 *
 * @param {=number?} index The 0-based index
 */
Nodeset.prototype.setIndex = function( index ) {
    this.index = index;
};

/**
 * Sets data node values.
 *
 * @param {(string|Array.&lt;string>)=} newVals    The new value of the node.
 * @param {?string=} xmlDataType XML data type of the node
 *
 * @return {?*} wrapping {?boolean}; null is returned when the node is not found or multiple nodes were selected,
 *                            otherwise an object with update information is returned.
 */
Nodeset.prototype.setVal = function( newVals, xmlDataType ) {
    let /**@type {string}*/ newVal;
    let updated;
    let customData;

    const curVal = this.getVal();

    if ( typeof newVals !== 'undefined' &amp;&amp; newVals !== null ) {
        newVal = ( Array.isArray( newVals ) ) ? newVals.join( ' ' ) : newVals.toString();
    } else {
        newVal = '';
    }

    newVal = this.convert( newVal, xmlDataType );
    const targets = this.getElements();

    if ( targets.length === 1 &amp;&amp; newVal.toString() !== curVal.toString() ) {
        const target = targets[ 0 ];
        // first change the value so that it can be evaluated in XPath (validated)
        target.textContent = newVal.toString();
        // then return validation result
        updated = this.getClosestRepeat();
        updated.nodes = [ target.nodeName ];

        customData = this.model.getUpdateEventData( target, xmlDataType );
        updated = ( customData ) ? $.extend( {}, updated, customData ) : updated;

        this.model.events.dispatchEvent( event.DataUpdate( updated ) );

        //add type="file" attribute for file references
        if ( xmlDataType === 'binary' ) {
            if ( newVal.length > 0 ) {
                target.setAttribute( 'type', 'file' );
            } else {
                target.removeAttribute( 'type' );
            }
        }
        return updated;
    }
    if ( targets.length > 1 ) {
        console.error( 'nodeset.setVal expected nodeset with one node, but received multiple' );
        return null;
    }
    if ( targets.length === 0 ) {
        console.log( `Data node: ${this.selector} with null-based index: ${this.index} not found. Ignored.` );
        return null;
    }

    return null;
};

/**
 * Obtains the data value of the first node.
 *
 * @return {string} [description]
 */
Nodeset.prototype.getVal = function() {
    const nodes = this.getElements();
    return nodes.length ? nodes[ 0 ].textContent : undefined;
};

// If repeats have not been cloned yet, they are not considered a repeat by this function
Nodeset.prototype.getClosestRepeat = function() {
    let el = this.getElement();
    let nodeName = el.nodeName;

    while ( nodeName &amp;&amp; nodeName !== 'instance' &amp;&amp; !( el.nextElementSibling &amp;&amp; el.nextElementSibling.nodeName === nodeName ) &amp;&amp; !( el.previousElementSibling &amp;&amp; el.previousElementSibling.nodeName === nodeName ) ) {
        el = el.parentElement;
        nodeName = el ? el.nodeName : null;
    }

    return ( !nodeName || nodeName === 'instance' ) ? {} : {
        repeatPath: this.model.getXPath( el, 'instance' ),
        repeatIndex: this.model.determineIndex( el )
    };
};

/**
 * Remove a repeat node
 */
Nodeset.prototype.remove = function() {
    const dataNode = this.getElement();

    if ( dataNode ) {
        const nodeName = dataNode.nodeName;
        const repeatPath = this.model.getXPath( dataNode, 'instance' );
        let repeatIndex = this.model.determineIndex( dataNode );
        const removalEventData = this.model.getRemovalEventData( dataNode );

        if ( !this.model.templates[ repeatPath ] ) {
            // This allows the model itseldataNodeout requiring the controller to call .extractFakeTemplates()
            // to extract non-jr:templates by assuming that node.remove() would only called for a repeat.
            this.model.extractFakeTemplates( [ repeatPath ] );
        }
        // warning: jQuery.next() to be avoided to support dots in the nodename
        let nextNode = dataNode.nextElementSibling;

        dataNode.remove();
        this._nodes = null;

        // For internal use
        this.model.events.dispatchEvent( event.DataUpdate( {
            nodes: null,
            repeatPath,
            repeatIndex
        } ) );

        // For all next sibling repeats to update formulas that use e.g. position(..)
        // For internal use
        while ( nextNode &amp;&amp; nextNode.nodeName == nodeName ) {
            nextNode = nextNode.nextElementSibling;

            this.model.events.dispatchEvent( event.DataUpdate( {
                nodes: null,
                repeatPath,
                repeatIndex: repeatIndex++
            } ) );
        }

        // For external use, if required with custom data.
        this.model.events.dispatchEvent( event.Removed( removalEventData ) );

    } else {
        console.error( `could not find node ${this.selector} with index ${this.index} to remove ` );
    }
};

/**
 * Convert a value to a specified data type( though always stringified )
 * @param  {?string=} x           value to convert
 * @param  {?string=} xmlDataType XML data type
 * @return {string}               string representation of converted value
 */
Nodeset.prototype.convert = ( x, xmlDataType ) => {
    if ( x.toString() === '' ) {
        return x;
    }
    if ( typeof xmlDataType !== 'undefined' &amp;&amp; xmlDataType !== null &amp;&amp;
        typeof types[ xmlDataType.toLowerCase() ] !== 'undefined' &amp;&amp;
        typeof types[ xmlDataType.toLowerCase() ].convert !== 'undefined' ) {
        return types[ xmlDataType.toLowerCase() ].convert( x );
    }
    return x;
};

Nodeset.prototype.validate = function( constraintExpr, requiredExpr, xmlDataType ) {
    const that = this;
    const result = {};

    // Avoid checking constraint if required is invalid
    return this.validateRequired( requiredExpr )
        .then( passed => {
            result.requiredValid = passed;
            return ( passed === false ) ? null : that.validateConstraintAndType( constraintExpr, xmlDataType );
        } )
        .then( passed => {
            result.constraintValid = passed;
            return result;
        } );
};

/**
 * Validate a value with an XPath Expression and /or xml data type
 * @param  {?string=} expr        XPath expression
 * @param  {?string=} xmlDataType XML datatype
 * @return {Promise} wrapping a boolean indicating if the value is valid or not; error also indicates invalid field, or problem validating it
 */
Nodeset.prototype.validateConstraintAndType = function( expr, xmlDataType ) {
    const that = this;
    let value;

    if ( !xmlDataType || typeof types[ xmlDataType.toLowerCase() ] === 'undefined' ) {
        xmlDataType = 'string';
    }

    // This one weird trick results in a small validation performance increase.
    // Do not obtain *the value* if the expr is empty and data type is string, select, select1, binary knowing that this will always return true.
    if ( !expr &amp;&amp; ( xmlDataType === 'string' || xmlDataType === 'select' || xmlDataType === 'select1' || xmlDataType === 'binary' ) ) {
        return Promise.resolve( true );
    }

    value = that.getVal();

    if ( value.toString() === '' ) {
        return Promise.resolve( true );
    }

    return Promise.resolve()
        .then( () => types[ xmlDataType.toLowerCase() ].validate( value ) )
        .then( typeValid => {
            const exprValid = ( typeof expr !== 'undefined' &amp;&amp; expr !== null &amp;&amp; expr.length > 0 ) ? that.model.evaluate( expr, 'boolean', that.originalSelector, that.index ) : true;

            return ( typeValid &amp;&amp; exprValid );
        } );
};

// TODO: rename to isTrue?
Nodeset.prototype.isRequired = function( expr ) {
    return !expr || expr.trim() === 'false()' ? false : expr.trim() === 'true()' || this.model.evaluate( expr, 'boolean', this.originalSelector, this.index );
};

Nodeset.prototype.validateRequired = function( expr ) {
    const that = this;

    // if the node has a value or there is no required expression
    if ( !expr || this.getVal() ) {
        return Promise.resolve( true );
    }

    // if the node does not have a value and there is a required expression
    return Promise.resolve()
        .then( () => // if the expression evaluates to true, the field is required, and the function returns false.
            !that.isRequired( expr ) );
};

// Placeholder function meant to be overwritten
FormModel.prototype.getUpdateEventData = () => /*node, type*/ {};

// Placeholder function meant to be overwritten
FormModel.prototype.getRemovalEventData = () => /* node */ {};

// Expose types to facilitate extending with custom types
FormModel.prototype.types = types;

export { FormModel };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/jquery-3.1.1.min.js"></script>

<script src="scripts/search.js"></script>




</body>
</html>
